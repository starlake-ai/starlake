"use strict";(self.webpackChunkstarlake=self.webpackChunkstarlake||[]).push([[7750],{6338:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var i=t(74848),s=t(28453);const r={},a="Load XML files",o={id:"guides/load/xml",title:"Load XML files",description:"Loading XML files is similar to loading JSON files where attributes may have nested or repeated attributes.",source:"@site/versioned_docs/version-1.2.0/0300-guides/200-load/130-xml.mdx",sourceDirName:"0300-guides/200-load",slug:"/guides/load/xml",permalink:"/starlake/docs/guides/load/xml",draft:!1,unlisted:!1,editUrl:"https://github.com/starlake-ai/starlake/edit/master/docs/versioned_docs/version-1.2.0/0300-guides/200-load/130-xml.mdx",tags:[],version:"1.2.0",sidebarPosition:130,frontMatter:{},sidebar:"starlakeSidebar",previous:{title:"Load JSON Files",permalink:"/starlake/docs/guides/load/json"},next:{title:"Load fixed width files",permalink:"/starlake/docs/guides/load/position"}},d={},l=[{value:"Infer schema",id:"infer-schema",level:2},{value:"Parsing XML",id:"parsing-xml",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"load-xml-files",children:"Load XML files"}),"\n",(0,i.jsxs)(n.p,{children:["Loading XML files is similar to loading JSON files where attributes may have nested or repeated attributes.\nthe difference is that in XML, child nodes and ",(0,i.jsx)(n.strong,{children:"node attributes"})," are used to represent the nested attributes."]}),"\n",(0,i.jsx)(n.p,{children:"Consider the following XML file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<data>\n    <country name="Liechtenstein">\n        <rank>1</rank>\n        <year>2008</year>\n        <gdppc>141100</gdppc>\n        <neighbor name="Austria" direction="E"/>\n        <neighbor name="Switzerland" direction="W"/>\n    </country>\n    <country name="Singapore">\n        <rank>4</rank>\n        <year>2011</year>\n        <gdppc>59900</gdppc>\n        <neighbor name="Malaysia" direction="N"/>\n    </country>\n</data>\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The parser needs to detect what tag identifies a row. In the example above, the tag ",(0,i.jsx)(n.code,{children:"country"})," identifies a row."]}),"\n",(0,i.jsxs)(n.p,{children:["Child nodes and node attributes are used to represent the nested attributes. In the example above, the ",(0,i.jsx)(n.code,{children:"country"})," tag will have the following attributes in the database table:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"_name"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"rank"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"year"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"gdppc"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"neighbor"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"_name"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"_direction"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Note that the ",(0,i.jsx)(n.code,{children:"_"})," prefix is used to differentiate node attributes from child nodes, to avoid name collisions."]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Also note that the target datawarehouse need to support nested and repeated attributes. For example, BigQuery and Databricks support nested and repeated attributes, while Redshift does not."})}),"\n",(0,i.jsx)(n.h2,{id:"infer-schema",children:"Infer schema"}),"\n",(0,i.jsxs)(n.p,{children:["The very first step is to infer the schema of the file from a data file as described in the ",(0,i.jsx)(n.a,{href:"autoload#how-autoload-detects-the-format-of-the-files",children:"autoload section"})," before you start customizing your configuration. This is done using the ",(0,i.jsx)(n.code,{children:"infer-schema"})," command. This will bootstrap the configuration file for the table."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"\nstarlake infer-schema --input-path incoming/starbake\n\n"})}),"\n",(0,i.jsx)(n.h2,{id:"parsing-xml",children:"Parsing XML"}),"\n",(0,i.jsx)(n.p,{children:"You may need to customize the configuration file to parse the XML file.\nThe main options to consider are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rowTag"}),": The tag that identifies a row in the XML file."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"attributePrefix"}),": The prefix used to identify node attributes (",(0,i.jsx)(n.code,{children:"_"})," by default)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rowValidationXSDPath"}),": The path to the XSD file used to validate the XML file."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Other options are available to customize the parsing of the XML file. You can find the full list of options in the ",(0,i.jsx)(n.a,{href:"https://github.com/databricks/spark-xml?tab=readme-ov-file#features",children:"Spark XML reference"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);