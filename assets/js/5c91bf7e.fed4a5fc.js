"use strict";(self.webpackChunkstarlake=self.webpackChunkstarlake||[]).push([[9045],{15680:(e,t,a)=>{a.d(t,{xA:()=>s,yg:()=>u});var n=a(96540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var g=n.createContext({}),d=function(e){var t=n.useContext(g),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},s=function(e){var t=d(e.components);return n.createElement(g.Provider,{value:t},e.children)},y="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,g=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),y=d(a),m=r,u=y["".concat(g,".").concat(m)]||y[m]||p[m]||i;return a?n.createElement(u,l(l({ref:t},s),{},{components:a})):n.createElement(u,l({ref:t},s))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=m;var o={};for(var g in t)hasOwnProperty.call(t,g)&&(o[g]=t[g]);o.originalType=e,o[y]="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=a[d];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},86084:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>g,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(9668),r=(a(96540),a(15680));const i={},l="Load",o={unversionedId:"configuration/load",id:"version-1.1.0/configuration/load",title:"Load",description:"Load Strategy",source:"@site/versioned_docs/version-1.1.0/0500-configuration/0130-load.mdx",sourceDirName:"0500-configuration",slug:"/configuration/load",permalink:"/docs/1.1.0/configuration/load",draft:!1,editUrl:"https://github.com/starlake-ai/starlake/edit/master/docs/versioned_docs/version-1.1.0/0500-configuration/0130-load.mdx",tags:[],version:"1.1.0",sidebarPosition:130,frontMatter:{},sidebar:"starlakeSidebar",previous:{title:"Filesystem",permalink:"/docs/1.1.0/configuration/filesystem"},next:{title:"Platforms",permalink:"/docs/1.1.0/category/platforms"}},g={},d=[{value:"Load Strategy",id:"load-strategy",level:2},{value:"Adaptive Load",id:"adaptive-load",level:2},{value:"List of valid write strategy",id:"list-of-valid-write-strategy",level:3},{value:"List of criterias",id:"list-of-criterias",level:3},{value:"Validation",id:"validation",level:2},{value:"Privacy",id:"privacy",level:2}],s={toc:d},y="wrapper";function p(e){let{components:t,...a}=e;return(0,r.yg)(y,(0,n.A)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"load"},"Load"),(0,r.yg)("h2",{id:"load-strategy"},"Load Strategy"),(0,r.yg)("p",null,"When many files that have the same pattern and thus belong to the same schema, it is possible to ingest them one after the other using an ingestion policy\nor ingest all of them at once."),(0,r.yg)("p",null,"When ingesting the files with the same schema one after the other, it is possible to use a custom ordering policy by settings the ",(0,r.yg)("inlineCode",{parentName:"p"},"SL_LOAD_STRATEGY")," environment variable. Currently, the following ordering policies are defined:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ai.starlake.job.load.IngestionTimeStrategy"),": Order the files by modification date"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ai.starlake.job.load.IngestionNameStrategy"),": Order  the files by name")),(0,r.yg)("p",null,"If you want to use another custom strategy, you'll have to implement the trait below, make it available in the classpath and set the ",(0,r.yg)("inlineCode",{parentName:"p"},"SL_LOAD_STRATEGY")," environment variable"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'package ai.starlake.job.load\n\nimport java.time.LocalDateTime\n\nimport org.apache.hadoop.fs.{FileSystem, Path}\n\ntrait LoadStrategy {\n\n  /** List all files in folder\n    *\n    * @param fs        FileSystem\n    * @param path      Absolute folder path\n    * @param extension Files should end with this string. To list all files, simply provide an empty string\n    * @param since     Minimum modification time of list files. To list all files, simply provide the beginning of all times\n    * @param recursive List files recursively\n    * @return List of Path\n    */\n  def list(\n    fs: FileSystem,\n    path: Path,\n    extension: String = "",\n    since: LocalDateTime = LocalDateTime.MIN,\n    recursive: Boolean\n  ): List[Path]\n}\n')),(0,r.yg)("p",null,"To ingest all the files at once, set the ",(0,r.yg)("inlineCode",{parentName:"p"},"SL_GROUPED")," variable to true."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"left"},"YAML Variable"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Env variable"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Default Value"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"grouped"),(0,r.yg)("td",{parentName:"tr",align:"left"},"SL_GROUPED"),(0,r.yg)("td",{parentName:"tr",align:"left"},"false"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Should files with the same schema be ingested all at once ?")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"loadStrategyClass"),(0,r.yg)("td",{parentName:"tr",align:"left"},"SL_LOAD_STRATEGY"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.job.load.IngestionTimeStrategy"),(0,r.yg)("td",{parentName:"tr",align:"left"},"When ",(0,r.yg)("inlineCode",{parentName:"td"},"grouped")," is false, which ingestion order strategy to use")))),(0,r.yg)("p",null,"Below is an example of YAML file with the default values."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'application:\n  load-strategy-class: "ai.starlake.job.load.IngestionTimeStrategy" # may be overriden by the ${?SL_LOAD_STRATEGY} env variable\n  grouped: false # may be overriden by the ${?SL_GROUPED} env variable\n')),(0,r.yg)("h2",{id:"adaptive-load"},"Adaptive Load"),(0,r.yg)("p",null,"Have you ever needed to change the way you feed your table from time to time or periodically?\nAdaptive Write may be the solution to your need. This feature allows you to adjust the loading mode at runtime,\naccording to various criteria listed in the table below."),(0,r.yg)("p",null,"For example, you want to ingest in APPEND mode throughout the week,\nexcept on Sundays when the source sends you all of certain tables,\nas discrepancies may occur with the incremental mode.\nThis can be done automatically by changing the domain or table configuration."),(0,r.yg)("p",null,"The example below illustrates the change at domain level that will be propagated to all these tables."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"# _config.sl.yml\nload:\n   name: \"DOMAIN\n   metadata:\n      ...\n      writeStrategy:\n         types:\n             APPEND: 'dayOfWeek != 7'\n             OVERWRITE: 'dayOfWeek == 7'\n")),(0,r.yg)("p",null,"Another example is based on the file name:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'# _config.sl.yml\nload:\n   name: "DOMAIN"\n   metadata:\n      ...\n      writeStrategy:\n         types:\n             OVERWRITE: \'group("mode") == "FULL"\'\n             APPEND: \'group("mode") == "APPEND"\'\n\n# my_table.sl.yml\ntable:\n  ...\n  pattern: ".*-(?<mode>FULL|APPEND).csv$"\n')),(0,r.yg)("p",null,"You may want to combine criterias. If so, just use regular boolean operators with ",(0,r.yg)("inlineCode",{parentName:"p"},"!"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"&&"),"and ",(0,r.yg)("inlineCode",{parentName:"p"},"||")," and wrap with parenthesis if necessary."),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"When using String in expression, makes sure to wrap them with double quotes ",(0,r.yg)("inlineCode",{parentName:"p"},'"'))),(0,r.yg)("h3",{id:"list-of-valid-write-strategy"},"List of valid write strategy"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"left"},"Strategy"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Description"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Requirements"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"APPEND"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Turn your load into APPEND mode. Ignore ",(0,r.yg)("inlineCode",{parentName:"td"},"merge")," and ",(0,r.yg)("inlineCode",{parentName:"td"},"dynamicPartitionOverwrite")," settings."),(0,r.yg)("td",{parentName:"tr",align:"left"},"None")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"OVERWRITE"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Turn your load into OVERWRITE mode. Ignore ",(0,r.yg)("inlineCode",{parentName:"td"},"merge")," and ",(0,r.yg)("inlineCode",{parentName:"td"},"dynamicPartitionOverwrite")," settings."),(0,r.yg)("td",{parentName:"tr",align:"left"},"None")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"UPSERT_BY_KEY"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Merge incoming data and target data using key. Incoming data for same key have higher precedence. Ignore ",(0,r.yg)("inlineCode",{parentName:"td"},"timestamp")," setting on ",(0,r.yg)("inlineCode",{parentName:"td"},"merge"),"."),(0,r.yg)("td",{parentName:"tr",align:"left"},(0,r.yg)("inlineCode",{parentName:"td"},"merge.key")," is defined")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"UPSERT_BY_KEY_AND_TIMESTAMP"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Merge incoming data and target data using key. Select the data with higher timestamp for each key."),(0,r.yg)("td",{parentName:"tr",align:"left"},(0,r.yg)("inlineCode",{parentName:"td"},"merge.key")," and ",(0,r.yg)("inlineCode",{parentName:"td"},"merge.timestamp")," is defined")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"OVERWRITE_BY_PARTITION"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Overwrite target partitions with incoming partitions. Ignore ",(0,r.yg)("inlineCode",{parentName:"td"},"merge")," setting."),(0,r.yg)("td",{parentName:"tr",align:"left"},(0,r.yg)("inlineCode",{parentName:"td"},"merge.key")," and ",(0,r.yg)("inlineCode",{parentName:"td"},"merge.timestamp")," is defined")))),(0,r.yg)("h3",{id:"list-of-criterias"},"List of criterias"),(0,r.yg)("p",null,"Criteria| Description | Example\ngroup(index|name) | File pattern must use (named) capture groups | pattern: ",(0,r.yg)("inlineCode",{parentName:"p"},"my-file-(F|D).csv$"),' => m.group(1) == "F"\nfileSize | Current file size in bytes | fileSize > 1000\nfileSizeB | Current file size in bytes. Alias of fileSize |\nfileSizeKo | Current file size in Ko |\nfileSizeMo | Current file size in Mo |\nfileSizeGo | Current file size in Go |\nfileSizeTo | Current file size in To |\nisFirstDayOfMonth | Current day is first day of month|\nisLastDayOfMonth | Current day is last day of month|\ndayOfWeek | Integer representing day of week. Monday = 1, ..., Sunday = 7|\nisFileFirstDayOfMonth | File modification date is first day of month|\nisFileLastDayOfMonth | File modification date is last day of month|\nfileDayOfWeek | Integer representing file modification day of week. Monday = 1, ..., Sunday = 7|'),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"For criterias relying on datetime, you can change its timezone with ",(0,r.yg)("inlineCode",{parentName:"p"},"timezone")," application setings in ",(0,r.yg)("inlineCode",{parentName:"p"},"application.sl.yml"))),(0,r.yg)("h2",{id:"validation"},"Validation"),(0,r.yg)("p",null,"During ingestion, the input file is validated up to the attribute level. Three default row validators are defined:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"ai.starlake.job.validator.FlatRowValidator: to validate flat files, eq. DSV, Fixed width and single level Json files."),(0,r.yg)("li",{parentName:"ul"},"ai.starlake.job.validator.TreeRowValidator:  used for tree like documents, eq. XML and JSON files"),(0,r.yg)("li",{parentName:"ul"},"ai.starlake.job.validator.AcceptAllValidator: used for any document type (flat and tree like) and accept the input without any validation")),(0,r.yg)("p",null,"The validtor to use is configurable as follows:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"left"},"YAML Variable"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Env. variable"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Default value"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"rowValidatorClass"),(0,r.yg)("td",{parentName:"tr",align:"left"},"SL_ROW_VALIDATOR_CLASS"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.job.validator.FlatRowValidator")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"treeValidatorClass"),(0,r.yg)("td",{parentName:"tr",align:"left"},"SL_TREE_VALIDATOR_CLASS"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.job.validator.TreeRowValidator")))),(0,r.yg)("h2",{id:"privacy"},"Privacy"),(0,r.yg)("p",null,"Default valid values are NONE, HIDE, MD5, SHA1, SHA256, SHA512, AES(not implemented).\nCustom values may also be defined by adding a new privacy option in the application.conf.\nThe default reference.conf file defines the following valid privacy strategies:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-hocon"},'privacy {\n  options = {\n    "none": "ai.starlake.utils.No",\n    "hide": "ai.starlake.utils.Hide",\n    "hide10X": "ai.starlake.utils.Hide(\\"X\\",10)",\n    "approxLong20": "ai.starlake.utils.ApproxLong(20)",\n    "md5": "ai.starlake.utils.Md5",\n    "sha1": "ai.starlake.utils.Sha1",\n    "sha256": "ai.starlake.utils.Sha256",\n    "sha512": "ai.starlake.utils.Sha512",\n    "initials": "ai.starlake.utils.Initials"\n  }\n}\n')),(0,r.yg)("p",null,"In the YAML/HOCON file, reference, you reference the option name. This will apply the function defined in the class referenced by the option value."),(0,r.yg)("p",null,"Below the predefined strategies:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"left"},"Privacy Strategy"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Privacy class"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"none"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.No"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the input string itself")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"hide"),(0,r.yg)("td",{parentName:"tr",align:"left"},'ai.starlake.utils.Hide(\\"X\\", 10)'),(0,r.yg)("td",{parentName:"tr",align:"left"},"Without a parameter, return the empty string. Otherwise, replace with 10 occurrences of the character 'X'")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"md5"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.Md5"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the md5 of the input string")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"sha1"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.Sha1"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the sha1 of the input string")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"sha256"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.Sha256"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the sha256 of the input string")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"sha512"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.Sha512"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the sha256 of the input string")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"initials"),(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.Initials"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the first char of each word (usually applied to user names)")))),(0,r.yg)("p",null,"The following startegies are also defined and may be declared in the custom configuration file."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"left"},"Privacy class"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.IPv4(8)"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the IPv4 address with the last 8 bytes masked")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.IPv6(8"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return the IPv6 address with the last 8 bytes masked")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.RandomDouble"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a random double number")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.RandomDouble(10,20)"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a random double between 10.0 and 20.0")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.RandomLong"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a random long number")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.RandomLong(10, 20)"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a random long number between 10 and 20")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.RandomInt"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a random int number")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.RandomInt(10, 20)"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a random int number between 10 and 20")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.ApproxDouble(70)"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a double value with a variation up to 70% applied to the input value")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},"ai.starlake.utils.ApproxLong(70)"),(0,r.yg)("td",{parentName:"tr",align:"left"},"Return a double long with a variation up to 70% applied to the input value")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"left"},'ai.starlake.utils.Mask(\\"*\\", 4, 1, 3)'),(0,r.yg)("td",{parentName:"tr",align:"left"},"Partially mask the input value with 4 occurrences of the '*' character, 1 on the left side and 3 on the right side.")))),(0,r.yg)("p",null,"Any new privacy strategy should implement the following trait:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"/** @param s: String  => Input string to encrypt\n  * @param colMap: Map[String, Option[String]] => Map of all the attributes and their corresponding values\n  * @param params: List[Any]  => Parameters passed to the algorithm as defined in the conf file.\n  *                               Parameter starting with '\"' is converted to a string\n  *                               Parameter containing a '.' is converted to a double\n  *                               Parameter equals to true of false is converted a boolean\n  *                               Anything else is converted to an int\n  * @return The encrypted string\n  */\n")))}p.isMDXComponent=!0}}]);