"use strict";(self.webpackChunkstarlake=self.webpackChunkstarlake||[]).push([[5428],{44541:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"rls-cls-big-query","metadata":{"permalink":"/starlake/blog/rls-cls-big-query","editUrl":"https://github.com/starlake-ai/starlake/edit/master/docs/blog/2022-02-15-rls-cls-big-query.mdx","source":"@site/blog/2022-02-15-rls-cls-big-query.mdx","title":"Column  and Row Level Security in BigQuery","description":"Data exposition strategies","date":"2022-02-15T00:00:00.000Z","formattedDate":"February 15, 2022","tags":[{"label":"Spark","permalink":"/starlake/blog/tags/spark"},{"label":"BigQuery","permalink":"/starlake/blog/tags/big-query"},{"label":"Dataproc","permalink":"/starlake/blog/tags/dataproc"},{"label":"Google Cloud","permalink":"/starlake/blog/tags/google-cloud"},{"label":"ETL","permalink":"/starlake/blog/tags/etl"},{"label":"Starlake","permalink":"/starlake/blog/tags/starlake"}],"readingTime":2.855,"hasTruncateMarker":false,"authors":[{"name":"Hayssam Saleh","title":"Starlake Core Team Member","url":"https://www.linkedin.com/in/hayssams/","imageURL":"https://s.gravatar.com/avatar/04aa2a859a66b52787bcba8c36beba8c.png"}],"frontMatter":{"slug":"rls-cls-big-query","title":"Column  and Row Level Security in BigQuery","author":"Hayssam Saleh","author_title":"Starlake Core Team Member","author_url":"https://www.linkedin.com/in/hayssams/","author_image_url":"https://s.gravatar.com/avatar/04aa2a859a66b52787bcba8c36beba8c.png","tags":["Spark","BigQuery","Dataproc","Google Cloud","ETL","Starlake"]},"nextItem":{"title":"Handling Dynamic Partitioning and Merge with Spark on BigQuery","permalink":"/starlake/blog/spark-big-query-partitioning"}},"content":"## Data exposition strategies\\n\\nData may be exposed using views or authorized views and more recently using Row / Column level security.\\n\\nHistorically, to restrict access on specific columns or rows in BigQuery, one can create a (authorized) view with a SQL request like the one below:\\n\\n![CLS / RLS using Views]( /img/blog/cls-rls-bigquery/cls-rls.png \\"CLS / RLS using Views\\")\\n\\n\\nBigQuery **Views** require to grant access for the end users to the table on top of which the view is created. To bypass that limitation,\\nBigQuery provide **Authorized views**. However, Authorized views come with the following restrictions:\\n\\n1.  The underlying table is accessed through the authorized view where the end user is impersonated,\\nloosing thus at the table level, the identity of the user making the request.\\n![Impersonation]( /img/blog/cls-rls-bigquery/cls-rls-impersonation.png \\"Impersonation\\")\\n\\n\\n2. Each restriction policy require to define a specific authorized view making it difficult to identify who has access to what ?\\n![Multiplication of Authorized Views]( /img/blog/cls-rls-bigquery/cls-rls-multiple-authorized.png \\"Multiplication of Authorized Views\\")\\n\\n\\n3. Authorized views need to be updated whenever a schema evolution on the underlying table bring in a sensitive field that need to be excluded or a field that need to be included in the view.\\nIn the example below, the new column \\"description\\" need to be added to the authorized view if we want it .\\n![Multiplication of Authorized Views]( /img/blog/cls-rls-bigquery/cls-rls-schema-evolution.png \\"Multiplication of Authorized Views\\")\\n\\n\\nThat\'s where Row Level Security and Column Level security features natively supported by BigQuery come in.\\n\\n## BigQuery Row Level Security\\n\\nRow Level Security restrict access to the rows based on the conditions set in the where clause using the custom SQL statement below:\\n\\n![RLS]( /img/blog/cls-rls-bigquery/rls-syntax.png \\"RLS\\")\\n\\n## Big Query Column Level Security\\n\\nColumn level security in BigQuery is managed using a taxonomy. This taxonomy is a hierarchy of policy tags\\ndescribing the table attributes or other resources. By assigning access rights to a tag,\\nwe restrict access to any resource tagged using this specific tag and this applies to BigQuery table fields.\\n\\nIn our example, restricting access to specific user/group/sa to the column `price` require the following steps:\\n\\n1. In Cloud Data Catalog/Policy Tags, create a Taxonomy. Note that `Enfore access control` should be checked.\\n\\n![CLS Taxonomy]( /img/blog/cls-rls-bigquery/cls-taxonomy.png \\"CLS Taxonomy\\")\\n\\n2. Assign permissions for each policy tag you defined\\n\\n![CLS Access]( /img/blog/cls-rls-bigquery/cls-tag-access.png \\"CLS Access\\")\\n\\n3. Tag restricted columns in the BigQuery schema editor.\\n![CLS Assign]( /img/blog/cls-rls-bigquery/cls-tag-assign.png \\"CLS Assign\\")\\n\\n:::tip\\nAssigning policy tags may be done using the `bq load/update` command line tool\\n:::\\n\\n## BigQuery RLS/CLS benefits\\n\\nUsing BigQuery row and column level security features bring several benefits:\\n- There is no need to create extra views\\n- Users use the same name for the table but with different access rights\\n- A company-wide taxonomy is defined allowing better Data Management\\n- Access rights to a new column in the table are automatically handled\\n\\n## A word about RLS and CLS in Starlake\\n\\nIngesting Data into BigQuery cannot be considered complete without taking into account the access level restrictions on the target table.\\nStarlake will handle for you all the scripting required to secure BigQuery rows and columns using a YAML declarative syntax to make sure\\nthat your tables are secured in BigQuery:\\n```yaml {2,11} title=\\"Declarative Row Level & Column Level Security\\"\\n  - name: \\"PRODUCT\\"\\n    rls:\\n      - name: \\"my-rls\\"\\n        predicate: \\"category like \'Food\'\\"\\n        grants:\\n          - \\"user:me@company.com\\"\\n          - \\"group:financegroup@company.com\\"\\n          - \\"sa:serviceacount@gserviceaccount.com\\"\\n    attributes:\\n      - name: \\"id\\"\\n        accessPolicy: PII\\n```\\n## Comments\\n[Let\'s continue the conversation on Discord](https://discord.com/channels/833336395430625310/908709208025858079)"},{"id":"spark-big-query-partitioning","metadata":{"permalink":"/starlake/blog/spark-big-query-partitioning","editUrl":"https://github.com/starlake-ai/starlake/edit/master/docs/blog/2021-12-15-spark-big-query-partitioning.mdx","source":"@site/blog/2021-12-15-spark-big-query-partitioning.mdx","title":"Handling Dynamic Partitioning and Merge with Spark on BigQuery","description":"Data Loading strategies","date":"2021-12-15T00:00:00.000Z","formattedDate":"December 15, 2021","tags":[{"label":"Spark","permalink":"/starlake/blog/tags/spark"},{"label":"BigQuery","permalink":"/starlake/blog/tags/big-query"},{"label":"Dataproc","permalink":"/starlake/blog/tags/dataproc"},{"label":"Google Cloud","permalink":"/starlake/blog/tags/google-cloud"},{"label":"ETL","permalink":"/starlake/blog/tags/etl"},{"label":"Starlake","permalink":"/starlake/blog/tags/starlake"}],"readingTime":6.735,"hasTruncateMarker":false,"authors":[{"name":"Hayssam Saleh","title":"Starlake Core Team Member","url":"https://www.linkedin.com/in/hayssams/","imageURL":"https://s.gravatar.com/avatar/04aa2a859a66b52787bcba8c36beba8c.png"}],"frontMatter":{"slug":"spark-big-query-partitioning","title":"Handling Dynamic Partitioning and Merge with Spark on BigQuery","author":"Hayssam Saleh","author_title":"Starlake Core Team Member","author_url":"https://www.linkedin.com/in/hayssams/","author_image_url":"https://s.gravatar.com/avatar/04aa2a859a66b52787bcba8c36beba8c.png","tags":["Spark","BigQuery","Dataproc","Google Cloud","ETL","Starlake"]},"prevItem":{"title":"Column  and Row Level Security in BigQuery","permalink":"/starlake/blog/rls-cls-big-query"},"nextItem":{"title":"Bonjour","permalink":"/starlake/blog/bonjour"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n\\n\\n## Data Loading strategies\\n\\nWhen loading data into BigQuery, you may want to:\\n- **Overwrite** the existing data and replace it with the incoming data.\\n- **Append** incoming data to existing\\n- **Dynamic partition Overwrite** where only the partitions to which the incoming data belong to are overwritten.\\n- **Merge** incoming data with existing data by keeping the newest version of each record.\\n\\nFor performance reasons, when having huge amount of data, tables are usually split\\ninto multiple partitions. BigQuery supports range partitioning which are uncommon and date/time partitioning\\nwhich is the most widely used type of partitioning.\\nThe diagram below shows our initial table partitioned by the `date` field.\\n\\n![Initial data]( /img/blog/spark-bigquery/initial-data.png \\"Initial data\\")\\n\\n\\nLet\'s assume we receive the following data that we need to ingest into the table:\\n\\n![Incoming data]( /img/blog/spark-bigquery/incoming-data.png \\"Incoming data\\")\\n\\nThe strategies above will produce respectively the results below:\\n\\n<Tabs groupId=\\"modes\\">\\n<TabItem value=\\"overwrite\\" label=\\"Overwrite\\">\\n\\nThe table ends up with the 2 incoming records.\\nAll existing partitions are deleted.\\n\\n![Overwrite data]( /img/blog/spark-bigquery/overwrite-data.png \\"Overwrite data\\")\\n\\n</TabItem>\\n<TabItem value=\\"append\\" label=\\"Append\\">\\n\\nThe table ends up with 7 records. Note that a new `\xectem 1` record is added while the older one is kept.\\n\\n![Append data]( /img/blog/spark-bigquery/append-data.png \\"Append data\\")\\n\\n</TabItem>\\n<TabItem value=\\"partitioned-overwrite\\" label=\\"Dynamic partition Overwrite\\">\\n\\nThe table ends up with 4 records.\\nThe second partition remains untouched while the first partition is erased and overwritten by with the incoming data.\\n\\n![Merge data]( /img/blog/spark-bigquery/partitioned-overwrite.png \\"Merge data\\")\\n\\n</TabItem>\\n<TabItem value=\\"merge\\" label=\\"Merge\\">\\n\\nThe table ends up with 4 records.\\nIncoming and existing records are added up but only the newest version of each product in the kept in the resulting table.\\n\\n![Merge data]( /img/blog/spark-bigquery/merge-data.png \\"Merge data\\")\\n\\n</TabItem>\\n</Tabs>\\n\\nThere is no good or bad strategy, the use of one of the strategies above depends on the use case. Some use case examples for each of the strategies are :\\n- Overwrite mode may be useful when you receive every day the list of all product names.\\n- Append mode may be useful when you receive daily sales.\\n- Dynamic Partition Overwrite mode may be useful when you ingested the first time a partition, and you need to ingest it again with a different set of data and thus alter only that partition.\\n- Merge mode may be useful when you receive product updates every day and that you need to keep only the last version of each product.\\n\\n\\n# Spark How-to\\n\\n[Apache Spark SQL connector for Google BigQuery](https://github.com/GoogleCloudDataproc/spark-bigquery-connector) makes BigQuery a first class citizen as a source and sink for Spark jobs.\\n\\n## Append and Overwrite modes in Spark\\n\\nBigQuery is supported by Spark as a source and sink through the [Spark BigQuery connector](https://github.com/GoogleCloudDataproc/spark-bigquery-connector)\\n\\nSpark comes out of the box with the ability to append or overwrite existing data using a predefined save mode :\\n\\n```scala\\n\\nval incomingDF = ... // Incoming data loaded with the correct schema\\nval bqTable = \\"project-id.dataset.table\\"\\nval saveMode = SaveMode.Overwrite // or SaveMode.Append fot he appending data\\nincomingDF.write\\n    .mode(saveMode)\\n    .partitionBy(\\"date\\")\\n    .format(\\"com.google.cloud.spark.bigquery\\")\\n    .option(\\"table\\", bqTable)\\n    .save()\\n\\n```\\n\\n### Dynamic Partition Overwrite mode in Spark\\n\\nTo activate dynamic partitioning, you need to set the configuration below before saving the data using the exact same code above :\\n```scala\\nspark.conf.set(\\"spark.sql.sources.partitionOverwriteMode\\",\\"DYNAMIC\\")\\n```\\n\\nUnfortunately, the BigQuery Spark connector does not support this feature (at the time of writing).\\nWe need to manually delete the partitions we want to overwrite first and then append the incoming data.\\n\\nAssuming the table is partitioned by the field `date` and the incoming data loaded in the incomingDF dataframe, the code below will\\nremove existing partitions that need to be overwritten.\\n\\n```scala {3,8} title=\\"Delete partitions that need to be updated\\"\\nval incomingDF = ... // Incoming data loaded with the correct schema\\nincomingDF\\n  .select(date_format(col(\\"date\\"), \\"yyyyMMdd\\").cast(\\"string\\"))\\n  .distinct()\\n  .collect()\\n  .map(_.getString(0))\\n  .foreach { partition =>\\n    bigQueryClient.deleteTable(TableId.of(datasetName, s\\"$table\\\\$$partition\\"));\\n  }\\n```\\n\\n:::tip\\nTo drop a table partition using the Google Cloud `bq` command line tool, you may use the following syntax:\\n\\n```shell\\nbq rm -t \'project-id.dataset.table$YYYYMMDD\'\\n```\\n:::\\n\\nWe now need to append the incomingDF to mimic the `dynamic partition overwrite` feature:\\n\\n```scala {3} title=\\"Append incoming partitions\\"\\nval incomingDF = ... // Incoming data loaded with the correct schema\\nval bqTable = \\"project-id.dataset.table\\"\\nval saveMode = SaveMode.Append\\nincomingDF.write\\n    .mode(saveMode)\\n    .partitionBy(\\"date\\")\\n    .format(\\"com.google.cloud.spark.bigquery\\")\\n    .option(\\"table\\", bqTable)\\n    .save()\\n```\\n\\n:::caution\\nThe issue with this approach is that if the program crashes during the \\"appending\\" of the incoming data, partitions will have been deleted and data would be lost.\\nHowever, you can still ingest the same file again in case of failure and the end result will be the same.\\n:::\\n\\n\\n\\n\\n### Dynamic Partition Merge in Spark\\n\\nWhen you need to keep the last version of the record for each product, both BigQuery and Databricks (the company behind Spark in case you lived on the moon the last ten years) support\\nthe merge SQL statement:\\n\\n```sql {5,7} title=\\"Merge records using SQL statement\\"\\nMERGE INTO target_table\\nUSING incoming_table\\nON target_table.product = incoming_table.product\\n    WHEN NOT MATCHED\\n\\t\\tTHEN INSERT *\\n\\tWHEN MATCHED AND incoming_table.date > target_table.date THEN\\n\\t\\tUPDATE SET *\\n/*\\n    WHEN MATCHED AND incoming_table.timestamp <= target_table.timestamp THEN\\n\\t\\tSKIP\\n*/\\n```\\n\\nUnfortunately the `MERGE` statement is not supported by Apache Spark. It is only supported by Databricks, its commercial version.\\n\\nTo do a merge using the Spark BigQuery connector, we need to do it by following the steps below :\\n\\n\\n**Step 1: Create a dataframe with all the rows**\\n\\n```scala\\nval allRowsDF =\\n    incomingDF\\n    .unionByName(existingDF)\\n```\\n\\n![Step 1]( /img/blog/spark-bigquery/step1-union-data.png \\"Step 1\\")\\n\\n\\n**Step 2: group by product and order each product occurrence by date descending**\\n\\n```scala\\nval orderingWindow =\\n    Window\\n      .partitionBy(\\"product\\")\\n      .orderBy(col(\\"date\\").desc, col(\\"product\\")))\\n\\nval orderedDF =\\n    allRowsDF\\n        .withColumn(\\"rownum\\", row_number.over(orderingWindow))\\n```\\n\\n![Step 2]( /img/blog/spark-bigquery/step2-ordering-data.png \\"Step 2\\")\\n\\n\\n\\nIn the step 2 above, each product is ordered by date with the most recent one first (descending order).\\nWe identify it by the `rownum` column.\\n\\n\\n**Step 3: Keep the most recent product**\\n\\n```scala {3}\\nval toKeepDF =\\n    orderedDF\\n        .where(col(\\"rownum\\") === 1)\\n        .drop(\\"rownum\\")\\n```\\n\\n![Step 3]( /img/blog/spark-bigquery/step3-keep-data.png \\"Step 3\\")\\n\\n\\n**Step 4: Overwrite existing partitions with the data we want to keep**\\n\\n```scala {3}\\n\\nval bqTable = \\"project-id.dataset.table\\"\\nval saveMode = SaveMode.Overwrite\\ntoKeepDF.write\\n    .mode(saveMode)\\n    .partitionBy(\\"date\\")\\n    .format(\\"com.google.cloud.spark.bigquery\\")\\n    .option(\\"table\\", bqTable)\\n    .save()\\n```\\n\\n![Step 4]( /img/blog/spark-bigquery/step4-save-data.png \\"Step 4\\")\\n\\n## Starlake How-to\\n\\n[Starlake](https://starlake.io) is a declarative Ingestion Framework based on YAML description files.<br/>\\nThe 4 ingestion strategies described above are supported through the settings below:\\n\\n<Tabs groupId=\\"modes\\">\\n<TabItem value=\\"overwrite\\" label=\\"Overwrite\\">\\n\\n```json {2} title=\\"application.conf\\"\\n// When set to \\"STATIC\\" all partitions are truncated before data is written in overwrite mode.\\nspark.sql.sources.partitionOverwriteMode = \\"STATIC\\"\\n```\\n\\n```yaml {8} title=\\"Schema Definition File\\"\\n     name: \\"mydb\\"\\n     directory: \\"...\\"\\n+    metadata:\\n    schemas:\\n      - name: \\"mytable\\"\\n        pattern: \\"data-.*.csv\\"\\n        metadata:\\n          mode: \\"Overwrite\\"\\n        attributes:\\n          - name: \\"date\\"\\n            type: \\"date\\"\\n            rename: \\"id\\"\\n          - name: \\"product\\"\\n            type: \\"string\\"\\n          - name: \\"price\\"\\n            type: \\"decimal\\"\\n```\\n\\n[See again manual Spark overwrite](#append-and-overwrite-modes-in-spark)\\n\\n</TabItem>\\n<TabItem value=\\"append\\" label=\\"Append\\">\\n\\n```json title=\\"application.conf\\"\\n// Irrelevant since we are only appending data afterwards\\nspark.sql.sources.partitionOverwriteMode = \\"STATIC\\" // or \\"DYNAMIC\\"\\n```\\n\\n```yaml {8} title=\\"Schema Definition File\\"\\n     name: \\"mydb\\"\\n     directory: \\"...\\"\\n+    metadata:\\n    schemas:\\n      - name: \\"mytable\\"\\n        pattern: \\"data-.*.csv\\"\\n        metadata:\\n          mode: \\"Append\\"\\n        attributes:\\n          - name: \\"date\\"\\n            type: \\"date\\"\\n            rename: \\"id\\"\\n          - name: \\"product\\"\\n            type: \\"string\\"\\n          - name: \\"price\\"\\n            type: \\"decimal\\"\\n```\\n\\n[See again manual Spark append](#append-and-overwrite-modes-in-spark)\\n\\n</TabItem>\\n<TabItem value=\\"partitioned-overwrite\\" label=\\"Dynamic partition Overwrite\\">\\n\\n```json {2} title=\\"application.conf\\"\\n// When set to \\"DYNAMIC\\", only partitions that are  affected will be truncated in overwrite mode.\\nspark.sql.sources.partitionOverwriteMode = \\"DYNAMIC\\"\\n```\\n\\n```yaml {8} title=\\"Schema Definition File\\"\\n     name: \\"mydb\\"\\n     directory: \\"...\\"\\n+    metadata:\\n    schemas:\\n      - name: \\"mytable\\"\\n        pattern: \\"data-.*.csv\\"\\n        metadata:\\n          mode: \\"Overwrite\\"\\n        attributes:\\n          - name: \\"date\\"\\n            type: \\"date\\"\\n            rename: \\"id\\"\\n          - name: \\"product\\"\\n            type: \\"string\\"\\n          - name: \\"price\\"\\n            type: \\"decimal\\"\\n```\\n\\n[See again manual Spark dynamic partition overwrite](#dynamic-partition-overwrite-mode-in-spark)\\n\\n</TabItem>\\n<TabItem value=\\"merge\\" label=\\"Merge\\">\\n\\n```json title=\\"application.conf\\"\\n// Irrelevant since we are truncating manually and  appending data afterwards\\nspark.sql.sources.partitionOverwriteMode = \\"DYNAMIC\\" // or STATIC\\n```\\n\\n```yaml {8,9,12,13} title=\\"Schema Definition File\\"\\n     name: \\"mydb\\"\\n     directory: \\"...\\"\\n+    metadata:\\n    schemas:\\n      - name: \\"mytable\\"\\n        pattern: \\"data-.*.csv\\"\\n        merge:\\n          key:\\n            - \\"product\\"\\n        metadata:\\n          mode: \\"Overwrite\\"\\n          partition:\\n            - \\"date\\"\\n        attributes:\\n          - name: \\"date\\"\\n            type: \\"date\\"\\n          - name: \\"product\\"\\n            type: \\"string\\"\\n          - name: \\"price\\"\\n            type: \\"decimal\\"\\n```\\n\\n[See again manual Spark Merge](#dynamic-partition-merge-in-spark)\\n\\n</TabItem>\\n</Tabs>\\n\\n## Comments\\n[Let\'s continue the conversation on Discord](https://discord.com/channels/833336395430625310/908709208025858079)"},{"id":"bonjour","metadata":{"permalink":"/starlake/blog/bonjour","editUrl":"https://github.com/starlake-ai/starlake/edit/master/docs/blog/2021-09-18-bonjour.md","source":"@site/blog/2021-09-18-bonjour.md","title":"Bonjour","description":"Pipelining fast data is big. Pipelining big data fast is bigger.  :)","date":"2021-09-18T00:00:00.000Z","formattedDate":"September 18, 2021","tags":[{"label":"bonjour","permalink":"/starlake/blog/tags/bonjour"},{"label":"Starlake","permalink":"/starlake/blog/tags/starlake"}],"readingTime":0.06,"hasTruncateMarker":false,"authors":[{"name":"Starlake Team","title":"Starlake Core Team","url":"https://github.com/starlake-ai","imageURL":"https://avatars.githubusercontent.com/u/89859410?s=200&v=4"}],"frontMatter":{"slug":"bonjour","title":"Bonjour","author":"Starlake Team","author_title":"Starlake Core Team","author_url":"https://github.com/starlake-ai","author_image_url":"https://avatars.githubusercontent.com/u/89859410?s=200&v=4","tags":["bonjour","Starlake"]},"prevItem":{"title":"Handling Dynamic Partitioning and Merge with Spark on BigQuery","permalink":"/starlake/blog/spark-big-query-partitioning"}},"content":"Pipelining fast data is big. Pipelining big data fast is bigger.  :)"}]}')}}]);