{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "$id": "https://json.schemastore.org/starlake.json",
  "title": "Starlake Data Pipeline",
  "description": "JSON Schema for Starlake Data Pipeline",
  "type": "object",
  "properties": {
    "version": {
      "type": "integer",
      "enum": [1]
    }
  },
  "allOf": [
    {
      "if": {
        "properties": {
          "version": {"const":  1}
        }
      },
      "then": {
        "$ref": "#/$defs/StarlakeV1"
      }
    }
  ],
  "required": ["version"],
  "unevaluatedProperties": false,
  "$defs": {
    "ConvertibleToString": {
      "anyOf": [
        {"type": "string"},
        {"type": "boolean"},
        {"type": "number"},
        {"type": "integer"},
        {"type": "null"}
      ]
    },
    "MergeOnV1": {
      "oneOf": [
        {
          "const": "TARGET",
          "description": "TODO"
        },
        {
          "const": "SOURCE_AND_TARGET",
          "description": "TODO"
        }
      ]
    },
    "PrimitiveTypeV1": {
      "description": "Define the value type",
      "$ref": "#/$defs/ConvertibleToString",
      "oneOf": [
        {
          "const": "string",
          "description": "Any string that match the '.*' regex"
        },
        {
          "const": "long",
          "description": "Any whole number that match the '[-|+|0-9][0-9]*' regex.\nints are mapped to as 'int' in some database whereas 'longs are mapped as 'bigint' and shorts as 'smallint'"
        },
        {
          "const": "int",
          "description": "Any whole number that match the '[-|+|0-9][0-9]*' regex.\nints are mapped to as 'int' in some database whereas 'longs are mapped as 'bigint' and shorts as 'smallint'"
        },
        {
          "const": "short",
          "description": "Any whole number that match the '[-|+|0-9][0-9]*' regex.\nints are mapped to as 'int' in some database whereas 'longs are mapped as 'bigint' and shorts as 'smallint'"
        },
        {
          "const": "double",
          "description": "Any decimal number that match the '[-+]?\\d*\\.?\\d+[Ee]?[-+]?\\d*' regex"
        },
        {
          "const": "boolean",
          "description": "Any string that match the '(?i)true|yes|[y1]<-TF->(?i)false|no|[n0]' regex,\nwhere the value on the left of '<-T' represent true and values on the right of 'F->' represent the false"
        },
        {
          "const": "byte",
          "description": "Any single char"
        },
        {
          "const": "date",
          "description": "Any date that match the 'yyyy-MM-dd' regex (2023-12-31)"
        },
        {
          "const": "timestamp",
          "description": "date/time that match the 'yyyy-MM-dd HH:mm:ss' regex s (2019-12-31 23:59:02).\nFor epoch timestamp, set pattern attribute to 'epoch_second' or 'epoch_milli'"
        },
        {
          "const": "decimal",
          "description": "Any floating value that match the '-?\\d*\\.{0,1}\\d+' regex"
        },
        {
          "const": "struct",
          "description": "Any attribute that has children. Set the array to true if this attribute is made of a list of attributes"
        }
      ]
    },
    "TrimV1": {
      "description": "How to trim the input string",
      "$ref": "#/$defs/ConvertibleToString",
      "oneOf": [
        {
          "const": "LEFT",
          "description": "Remove all leading space chars from the input"
        },
        {
          "const": "RIGHT",
          "description": "Remove all trailing spaces from the input"
        },
        {
          "const": "BOTH",
          "description": "Remove all leading and trailing spaces from the input"
        },
        {
          "const": "NONE",
          "description": "Do not remove leading or trailing spaces from the input"
        }
      ]
    },
    "TableDdlV1": {
      "description": "DDL used to create a table",
      "type": "object",
      "properties": {
        "createSql": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "SQL CREATE DDL statement"
        },
        "pingSql": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "How to test if the table exist.\nUse the following statement by default: 'select count(*) from tableName where 1=0'"
        },
        "selectSql": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Override the default select defined by Starlake"
        }
      },
      "required": ["createSql"],
      "unevaluatedProperties": false
    },
    "TableTypeBase": {
      "$ref": "#/$defs/ConvertibleToString",
      "description": "Table types supported by the Extract module",
      "oneOf": [
        {
          "const": "TABLE",
          "description": "SQl Table"
        },
        {
          "const": "VIEW",
          "description": "SQl View"
        },
        {
          "const": "SYSTEM TABLE",
          "description": "Database specific system table"
        },
        {
          "const": "MATERIALIZED VIEW",
          "description": "SQL Materialized View"
        },
        {
          "const": "GLOBAL TEMPORARY",
          "description": ""
        },
        {
          "const": "LOCAL TEMPORARY",
          "description": ""
        },
        {
          "const": "ALIAS",
          "description": "Table alias"
        },
        {
          "const": "SYNONYM",
          "description": "Table synonym"
        }
      ]
    },
    "TableTypeV1": {
      "$ref": "#/$defs/ConvertibleToString",
      "description": "Table types supported by the Extract module",
      "oneOf": [
        {
          "$ref": "#/$defs/TableTypeBase"
        },
        {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Any valid table types",
          "not": {
            "$ref": "#/$defs/TableTypeBase"
          }
        }
      ]
    },
    "TypeV1": {
      "type": "object",
      "description": "Custom type definition. Custom types are defined in the types/types.sl.yml file",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "unique id for this type"
        },
        "pattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Regex used to validate the input field"
        },
        "primitiveType": {
          "$ref": "#/$defs/PrimitiveTypeV1",
          "description": "To what primitive type should this type be mapped.\n This is the memory representation of the type, When saving, this primitive type is mapped to the database specific type. Default: string"
        },
        "zone": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "useful when parsing specific string:\n - double: To parse a french decimal (comma as decimal separator) set it to fr_FR locale.\n- decimal: to set the precision and scale of this number, '38,9' by default.\n- "
        },
        "sample": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "This field makes sure that the pattern matches the value you want to match. This will be checked on startup"
        },
        "comment": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Describes this type"
        },
        "ddlMapping": {
          "$ref": "#/$defs/MapString",
          "description": "Configure here the type mapping for each datawarehouse.\\nWill be used when inferring DDL from schema."
        }
      },
      "required": ["name", "pattern"],
      "unevaluatedProperties": false
    },
    "PositionV1": {
      "description": "First and last char positions of an attribute in a fixed length record",
      "type": "object",
      "properties": {
        "first": {
          "type": "number",
          "description": "Zero based position of the first character for this attribute"
        },
        "last": {
          "type": "number",
          "description": "Zero based position of the last character to include in this attribute"
        }
      },
      "required": ["first", "last"],
      "unevaluatedProperties": false
    },
    "ConnectionV1": {
      "description": "Connection properties to a datawarehouse.",
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "aka jdbc, bigquery, snowflake, redshift ..."
        },
        "sparkFormat": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Set only if you want to use the Spark engine"
        },
        "quote": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Set only if you want to use the Spark engine"
        },
        "separator": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Set only if you want to use the Spark engine"
        },
        "options": {
          "$ref": "#/$defs/MapString",
          "description": "Connection options"
        }
      },
      "required": ["type"],
      "unevaluatedProperties" : false
    },
    "DagGenerationConfigV1": {
      "description": "Dag configuration.",
      "type": "object",
      "properties": {
        "comment": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Dag config description"
        },
        "template": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Dag template to use for this config. Usually a .py.j2 file"
        },
        "filename": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "{schedule}, {domain}, {table} in the file name are used for DAG generation purposes"
        },
        "options": {
          "$ref": "#/$defs/MapString",
          "description": "DAG generation options"
        }
      },
      "required": ["comment", "template", "filename"],
      "unevaluatedProperties" : false
    },
    "RowLevelSecurityV1": {
      "description": "Row level security policy to apply to the output data.",
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "This Row Level Security unique name"
        },
        "predicate": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "The condition that goes to the WHERE clause and limit the visible rows."
        },
        "grants": {
          "description": "user / groups / service accounts to which this security level is applied.\nex : user:me@mycompany.com,group:group@mycompany.com,serviceAccount:mysa@google-accounts.com",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "description": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Description for this access policy"
        }
      },
      "required": ["name", "grants"],
      "unevaluatedProperties" : false
    },
    "AccessControlEntryV1": {
      "description": "Column level security policy to apply to the attribute.",
      "type": "object",
      "properties": {
        "role": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "This role to give to the granted users"
        },
        "grants": {
          "description": "user / groups / service accounts to which this security level is applied.\nex : user:me@mycompany.com,group:group@mycompany.com,serviceAccount:mysa@google-accounts.com",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "name": {
          "description": "TODO",
          "$ref": "#/$defs/ConvertibleToString"
        }
      },
      "required": ["role", "grants"],
      "unevaluatedProperties" : false
    },
    "FormatV1": {
      "description": "DSV by default. Supported file formats are :\\n- DSV : Delimiter-separated values file. Delimiter value is specified in the \"separator\" field.\\n- POSITION : FIXED format file where values are located at an exact position in each line.\\n- SIMPLE_JSON : For optimisation purpose, we differentiate JSON with top level values from JSON\\n  with deep level fields. SIMPLE_JSON are JSON files with top level fields only.\\n- JSON :  Deep JSON file. Use only when your json documents contain sub-documents, otherwise prefer to\\n  use SIMPLE_JSON since it is much faster.\\n- XML : XML files",
      "$ref": "#/$defs/ConvertibleToString",
      "oneOf": [
        {
          "const": "DSV",
          "description": "any single or multiple character delimited file. Separator is specified in the separator field"
        },
        {
          "const": "POSITION",
          "description": "any fixed position file. Positions are specified in the position field"
        },
        {
          "const": "JSON",
          "description": "any deep json file.\nTo improve performance, prefer the SIMPLE_JSON format if your json documents are flat"
        },
        {
          "const": "ARRAY_JSON",
          "description": "any json file containing an array of json objects."
        },
        {
          "const": "SIMPLE_JSON",
          "description": "any flat json file.\nTo improve performance, prefer this format if your json documents are flat"
        },
        {
          "const": "XML",
          "description": "any xml file. Use the metadata.xml.rowTag field to specify the root tag of your xml file"
        },
        {
          "const": "TEXT_XML",
          "description": "TODO"
        },
        {
          "const": "KAFKA",
          "description": "TODO"
        },
        {
          "const": "KAFKASTREAM",
          "description": "TODO"
        },
        {
          "const": "GENERIC",
          "description": "TODO"
        },
        {
          "const": "PARQUET",
          "description": "TODO"
        }
      ]
    },
    "MapString": {
      "type": "object",
      "description": "Map of string",
      "additionalProperties": {
        "$ref": "#/$defs/ConvertibleToString"
      }
    },
    "MapConnectionV1": {
      "type": "object",
      "description": "Map of jdbc engines",
      "additionalProperties": {
        "$ref": "#/$defs/ConnectionV1"
      }
    },
    "MapJdbcEngineV1": {
      "type": "object",
      "description": "Map of jdbc engines",
      "additionalProperties": {
        "$ref": "#/$defs/JdbcEngineV1"
      }
    },
    "MapTableDdlV1": {
      "type": "object",
      "description": "Map of table ddl",
      "additionalProperties": {
        "$ref": "#/$defs/TableDdlV1"
      }
    },
    "JdbcEngineV1": {
      "type": "object",
      "description": "Jdbc engine",
      "properties": {
        "tables": {
          "$ref": "#/$defs/MapTableDdlV1",
          "description": "List of all SQL create statements used to create audit tables for this JDBC engine.\nTables are created only if the execution of the pingSQL statement fails"
        },
        "canMerge": {
          "type": "boolean",
          "description": "TODO"
        },
        "quote": {
          "type": "string",
          "description": "TODO"
        },
        "viewPrefix": {
          "type": "string",
          "description": "TODO"
        },
        "preActions": {
          "type": "string",
          "description": "TODO"
        },
        "strategyBuilder": {
          "type": "string",
          "description": "TODO"
        }
      },
      "required": ["tables", "canMerge", "quote", "viewPrefix", "preActions", "strategyBuilder"],
      "unevaluatedProperties" : false
    },
    "PrivacyV1": {
      "type": "object",
      "properties": {
        "options": {
          "$ref": "#/$defs/MapString",
          "description": "Privacy strategies. The following default strategies are defined by default:\n- none: Leave the data as is\n- hide: replace the data with an empty string\n- hideX(\"s\", n): replace the string with n occurrences of the string 's'\n- md5: Redact the data using the MD5 algorithm\n- sha1: Redact the data using the SHA1 algorithm\n- sha256: Redact the data using the SHA256 algorithm\n - sha512: Redact the data using the SHA512 algorithm\n- initials: keep only the first char of each word in the data"
        }
      },
      "unevaluatedProperties" : false
    },
    "InternalV1": {
      "type": "object",
      "description": "configure Spark internal options",
      "properties": {
        "cacheStorageLevel": {
          "description": "How the RDD are cached. Default is MEMORY_AND_DISK_SER.\nAvailable options are (https://spark.apache.org/docs/latest/api/java/index.html?org/apache/spark/storage/StorageLevel.html):\n- MEMORY_ONLY\n- MEMORY_AND_DISK\n- MEMORY_ONLY_SER\n- MEMORY_AND_DISK_SER\n- DISK_ONLY\n- OFF_HEAP",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "intermediateBigqueryFormat": {
          "description": "May be parquet or ORC. Default is parquet. Used for BigQuery intermediate storage. Use ORC for for JSON files to keep the original data structure.\nhttps://stackoverflow.com/questions/53674838/spark-writing-parquet-arraystring-converts-to-a-different-datatype-when-loadin",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "temporaryGcsBucket": {
          "description": "The GCS bucket that temporarily holds the data before it is loaded to BigQuery.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "substituteVars": {
          "description": "Internal use. Do not modify.",
          "type": "boolean"
        },
        "bqAuditSaveInBatchMode": {
          "description": "TODO",
          "type": "boolean"
        }
      },
      "unevaluatedProperties" : false
    },
    "AccessPoliciesV1": {
      "type": "object",
      "properties": {
        "apply": {
          "description": "Should access policies be enforced ?",
          "type": "boolean"
        },
        "location": {
          "description": "GCP project location. Required if apply is true.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "database": {
          "description": "GCP Project id. Required if apply is true.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "taxonomy": {
          "description": "Taxonomy name. Required if apply is true.",
          "$ref": "#/$defs/ConvertibleToString"
        }
      },
      "unevaluatedProperties" : false
    },
    "SparkSchedulingV1": {
      "type": "object",
      "properties": {
        "maxJobs": {
          "description": "Max number of Spark jobs to run in parallel, default is 1",
          "type": "integer"
        },
        "poolName": {
          "description": "Pool name to use for Spark jobs, default is 'default'",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "mode": {
          "description": "This can be FIFO or FAIR, to control whether jobs within the pool queue up behind each other (the default) or share the poolâ€™s resources fairly.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "file": {
          "description": "Scheduler filename in the metadata folder. If not set, defaults to fairscheduler.xml.",
          "$ref": "#/$defs/ConvertibleToString"
        }
      },
      "unevaluatedProperties" : false
    },
    "ExpectationsConfigV1": {
      "type": "object",
      "properties": {
        "path": {
          "description": "When using filesystem storage, the path to the expectations file",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "active": {
          "description": "should expectations be executed ?",
          "type": "boolean"
        },
        "failOnError": {
          "description": "should load / transform fail on expectation error ?",
          "type": "boolean"
        }
      },
      "unevaluatedProperties" : false
    },
    "MetricsV1": {
      "type": "object",
      "properties": {
        "path": {
          "description": "When using filesystem storage, the path to the metrics file",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "discreteMaxCardinality": {
          "description": "Max number of unique values accepted for a discrete column. Default is 10",
          "type": "integer"
        },
        "active": {
          "description": "Should metrics be computed ?",
          "type": "boolean"
        }
      },
      "unevaluatedProperties" : false
    },
    "AllSinksV1": {
      "type": "object",
      "properties": {
        "connectionRef": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "JDBC: Connection String"
        },
        "clustering": {
          "description": "FS or BQ: List of attributes to use for clustering",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "days": {
          "type": "number",
          "description": "BQ: Number of days before this table is set as expired and deleted. Never by default."
        },
        "requirePartitionFilter": {
          "type": "boolean",
          "description": "BQ: Should be require a partition filter on every request ? No by default."
        },
        "materializedView": {
          "type": "boolean",
          "description": "BQ: Should we materialize as a table or as a view when saving the results ? false by default."
        },
        "enableRefresh": {
          "type": "boolean",
          "description": "BQ: Enable automatic refresh of materialized view ? false by default."
        },
        "refreshIntervalMs": {
          "type": "number",
          "description": "BQ: Refresh interval in milliseconds. Default to BigQuery default value"
        },
        "id": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "ES: Attribute to use as id of the document. Generated by Elasticsearch if not specified."
        },
        "format": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "FS: File format"
        },
        "extension": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "FS: File extension"
        },
        "partition": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "FS or BQ: List of partition attributes"
        },
        "coalesce": {
          "type": "boolean",
          "description": "When outputting files, should we coalesce it to a single file. Useful when CSV is the output format."
        },
        "options": {
          "$ref": "#/$defs/MapString",
          "description": "spark  options to use"
        }
      },
      "unevaluatedProperties" : false
    },
    "WriteStrategyTypeBase": {
      "$ref": "#/$defs/ConvertibleToString",
      "description": "TODO",
      "oneOf": [
        {
          "const": "OVERWRITE",
          "description": "TODO"
        },
        {
          "const": "APPEND",
          "description": "TODO"
        },
        {
          "const": "UPSERT_BY_KEY",
          "description": "TODO"
        },
        {
          "const": "UPSERT_BY_KEY_AND_TIMESTAMP",
          "description": "TODO"
        },
        {
          "const": "SCD2",
          "description": "TODO"
        },
        {
          "const": "OVERWRITE_BY_PARTITION",
          "description": "TODO"
        }
      ]
    },
    "WriteStrategyTypeV1": {
      "$ref": "#/$defs/ConvertibleToString",
      "description": "Table types supported by the Extract module",
      "oneOf": [
        {
          "$ref": "#/$defs/WriteStrategyTypeBase"
        }
      ]
    },
    "OpenWriteStrategyTypeV1": {
      "$ref": "#/$defs/ConvertibleToString",
      "description": "Table types supported by the Extract module",
      "oneOf": [
        {
          "$ref": "#/$defs/WriteStrategyTypeBase"
        },
        {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Any valid table types",
          "not": {
            "$ref": "#/$defs/WriteStrategyTypeBase"
          }
        }
      ]
    },
    "WriteStrategyV1": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/$defs/WriteStrategyTypeV1",
          "description": "TODO"
        },
        "types": {
          "type": "object",
          "description": "TODO",
          "additionalProperties": {
            "$ref": "#/$defs/OpenWriteStrategyTypeV1"
          }
        },
        "key": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          },
          "description": "TODO"
        },
        "timestamp": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "queryFilter": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "on": {
          "$ref": "#/$defs/MergeOnV1",
          "description": "TODO"
        },
        "startTs": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "endTs": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        }
      },
      "unevaluatedProperties" : false
    },
    "MetadataV1": {
      "type": "object",
      "properties": {
        "format": {
          "$ref": "#/$defs/FormatV1"
        },
        "encoding": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "UTF-8 if not specified."
        },
        "multiline": {
          "type": "boolean",
          "description": "are json objects on a single line or multiple line ? Single by default.  false means single. false also means faster"
        },
        "array": {
          "type": "boolean",
          "description": "Is the json stored as a single object array ? false by default. This means that by default we have on json document per line."
        },
        "withHeader": {
          "type": "boolean",
          "description": "does the dataset has a header ? true by default"
        },
        "separator": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "the values delimiter,  ';' by default value may be a multichar string starting from Spark3"
        },
        "quote": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "The String quote char, '\"' by default"
        },
        "escape": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "escaping char '\\' by default"
        },
        "sink": {
          "$ref": "#/$defs/AllSinksV1"
        },
        "ignore": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Pattern to ignore or UDF to apply to ignore some lines"
        },
        "directory": {
          "description": "Folder on the local filesystem where incoming files are stored.\n Typically, this folder will be scanned periodically to move the dataset to the cluster for ingestion.\n                     Files located in this folder are moved to the pending folder for ingestion by the \"import\" command.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "extensions": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          },
          "description": "recognized filename extensions. json, csv, dsv, psv are recognized by default.\nOnly files with these extensions will be moved to the pending folder."
        },
        "ack": {
          "description": "Ack extension used for each file. \".ack\" if not specified.\nFiles are moved to the pending folder only once a file with the same name as the source file and with this extension is present.\nTo move a file without requiring an ack file to be present, set explicitly this property to the empty string value \"\".",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "options": {
          "$ref": "#/$defs/MapString",
          "description": "Options to add to the spark reader"
        },
        "loader": {
          "description": "Loader to use, 'spark' or 'native'. Default to 'spark' of SL_LOADER env variable is set to 'native'",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "emptyIsNull": {
          "description": "Treat empty columns as null in DSV files. Default to false",
          "type": "boolean"
        },
        "dagRef": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Cron expression to use for this domain/table"
        },
        "freshness": {
          "$ref": "#/$defs/FreshnessV1",
          "description": "Configure freshness checks on this dataset"
        },
        "nullValue": {
          "description": "Treat a specific input string as a null value indicator",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "schedule": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Cron expression to use for this domain/table"
        },
        "writeStrategy": {
          "$ref": "#/$defs/WriteStrategyV1",
          "description": "TODO"
        }
      },
      "unevaluatedProperties" : false
    },
    "ExternalDomainV1": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Schema in JDBC Database / Snowflake / Redshift or Dataset in BigQuery"
        },
        "tables": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          },
          "description": "Tables to scan in this domain"
        }
      },
      "required": ["name"],
      "unevaluatedProperties" : false
    },
    "ExternalDatabaseV1": {
      "type": "object",
      "properties": {
        "project": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Database name of Project id in BigQuery"
        },
        "domains": {
          "description": "List of domains to scan",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ExternalDomainV1"
          }
        }
      },
      "required": ["project"],
      "unevaluatedProperties" : false
    },
    "ExternalSourceV1": {
      "type": "object",
      "properties": {
        "projects": {
          "type": "array",
          "description": "Database name of Project id in BigQuery",
          "items": {
            "$ref": "#/$defs/ExternalDatabaseV1"
          }
        }
      },
      "unevaluatedProperties" : false
    },
    "AreaV1": {
      "type": "object",
      "properties": {
        "pending": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Files recognized by the extensions property are moved to this folder for ingestion by the \"import\" command."
        },
        "unresolved": {
          "description": "Files that cannot be ingested (do not match by any table pattern) are moved to this folder.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "archive": {
          "description": "Files that have been ingested are moved to this folder if SL_ARCHIVE is set to true.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "ingesting": {
          "description": "Files that are being ingested are moved to this folder.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "accepted": {
          "description": "When filesystem storage is used, successfully ingested stored in this this folder in parquet format or any format set by the SL_DEFAULT_WRITE_FORMAT env property.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "rejected": {
          "description": "When filesystem storage is used, rejected records are stored in this folder in parquet format or any format set by the SL_DEFAULT_WRITE_FORMAT env property.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "replay": {
          "description": "Invalid records are stored in this folder in source format when SL_SINK_REPLAY_TO_FILE is set to true.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "business": {
          "description": "",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "hiveDatabase": {
          "description": "",
          "$ref": "#/$defs/ConvertibleToString"
        }
      },
      "unevaluatedProperties": false
    },
    "FreshnessV1": {
      "type": "object",
      "properties": {
        "warn": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "How old may be the data before a warning is raised. Use syntax like '3 day' or '2 hour' or '30 minute'"
        },
        "error": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "How old may be the data before an error is raised. Use syntax like '3 day' or '2 hour' or '30 minute'"
        }
      },
      "unevaluatedProperties": false
    },
    "TableV1": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Schema name, must be unique among all the schemas belonging to the same domain.\n  *                     Will become the hive table name On Premise or BigQuery Table name on GCP."
        },
        "pattern": {
          "description": "filename pattern to which this schema must be applied.\n  *                     This instructs the framework to use this schema to parse any file with a filename that match this pattern.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "attributes": {
          "description": "Attributes parsing rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/AttributeV1"
          }
        },
        "metadata": {
          "$ref": "#/$defs/MetadataV1",
          "description": "Dataset metadata"
        },
        "comment": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "free text"
        },
        "presql": {
          "type": "array",
          "description": "Reserved for future use.",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "postsql": {
          "type": "array",
          "description": "Reserved for future use.",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "tags": {
          "description": "Set of string to attach to this Schema",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "rls": {
          "description": " Row level security on this schema.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/RowLevelSecurityV1"
          }
        },
        "expectations": {
          "description": "Expectations to check after Load / Transform has succeeded",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "primaryKey": {
          "description": "List of columns that make up the primary key",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "acl": {
          "description": "Map of rolename -> List[Users].",
          "type": "array",
          "items": {
            "$ref": "#/$defs/AccessControlEntryV1"
          }
        },
        "rename": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "If present, the table is renamed with this name. Useful when use in conjunction with the 'extract' module"
        },
        "sample": {
          "description": "Store here a couple of records illustrating the table data.",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "filter": {
          "description": "remove all records that do not match this condition",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "patternSample": {
          "description": "Sample of filename matching this schema",
          "$ref": "#/$defs/ConvertibleToString"
        }
      },
      "required": ["name", "pattern", "attributes"],
      "unevaluatedProperties": false
    },
    "MetricTypeV1": {
      "$ref": "#/$defs/ConvertibleToString",
      "description": "TODO",
      "oneOf": [
        {
          "const": "DISCRETE",
          "description": "TODO"
        },
        {
          "const": "CONTINUOUS",
          "description": "TODO"
        },
        {
          "const": "TEXT",
          "description": "TODO"
        },
        {
          "const": "NONE",
          "description": "TODO"
        }
      ]
    },
    "AttributeV1": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Attribute name as defined in the source dataset and as received in the file"
        },
        "type": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "semantic type of the attribute. Default to string"
        },
        "array": {
          "type": "boolean",
          "description": "Is it an array ?"
        },
        "required": {
          "type": "boolean",
          "description": "Should this attribute always be present in the source. Default to true."
        },
        "privacy": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Should this attribute be applied a privacy transformation at ingestion time"
        },
        "comment": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "free text for attribute description"
        },
        "rename": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "If present, the attribute is renamed with this name"
        },
        "metricType": {
          "$ref": "#/$defs/MetricTypeV1",
          "description": "If present, what kind of stat should be computed for this field"
        },
        "attributes": {
          "type": "array",
          "description": "List of sub-attributes (valid for JSON and XML files only)",
          "items": {
            "$ref": "#/$defs/AttributeV1"
          }
        },
        "position": {
          "$ref": "#/$defs/PositionV1"
        },
        "default": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default value for this attribute when it is not present."
        },
        "tags": {
          "type": "array",
          "description": "Tags associated with this attribute",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "trim": {
          "$ref": "#/$defs/TrimV1"
        },
        "script": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Scripted field : SQL request on renamed column"
        },
        "foreignKey": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "If this attribute is a foreign key, reference to [domain.]table[.attribute]"
        },
        "ignore": {
          "type": "boolean",
          "description": "Should this attribute be ignored on ingestion. Default to false"
        },
        "accessPolicy": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Policy tag to assign to this attribute. Used for column level security"
        }
      },
      "required": ["name"],
      "unevaluatedProperties": false
    },
    "AutoTaskDescV1": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
        },
        "sql": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
        },
        "database": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set."
        },
        "domain": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Output domain in output Area (Will be the Database name in Hive or Dataset in BigQuery)"
        },
        "table": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Dataset Name in output Area (Will be the Table name in Hive & BigQuery)"
        },
        "partition": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          },
          "description": "List of columns used for partitioning the output."
        },
        "presql": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          },
          "description": "List of SQL requests to executed before the main SQL request is run"
        },
        "postsql": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          },
          "description": "List of SQL requests to executed after the main SQL request is run"
        },
        "sink": {
          "$ref": "#/$defs/AllSinksV1"
        },
        "rls": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/RowLevelSecurityV1"
          }
        },
        "expectations": {
          "description": "Expectations to check after Load / Transform has succeeded",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "acl": {
          "description": "Map of rolename -> List[Users].",
          "type": "array",
          "items": {
            "$ref": "#/$defs/AccessControlEntryV1"
          }
        },
        "comment": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Output table description"
        },
        "freshness": {
          "$ref": "#/$defs/FreshnessV1",
          "description": "Configure freshness checks on the output table"
        },
        "attributesDesc": {
          "description": "Attributes comments and access policies",
          "type": "array",
          "items": {
            "$ref": "#/$defs/AttributeDescV1"
          }
        },
        "python": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Python script URI to execute instead of the SQL request"
        },
        "tags": {
          "description": "Set of string to attach to the output table",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "writeStrategy": {
          "$ref": "#/$defs/WriteStrategyV1",
          "description": "TODO"
        },
        "schedule": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Cron expression to use for this task"
        },
        "dagRef": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Cron expression to use for this domain/table"
        },
        "taskTimeoutMs": {
          "type": "integer",
          "description": "Number of milliseconds before a communication timeout."
        },
        "parseSQL": {
          "type": "boolean",
          "description": "TODO"
        }
      },
      "required": [],
      "unevaluatedProperties": false
    },
    "DurationUnit": {
      "$ref": "#/$defs/ConvertibleToString",
      "oneOf": [
        {
          "const": "NANOSECONDS"
        },
        {
          "const": "MICROSECONDS"
        },
        {
          "const": "MILLISECONDS"
        },
        {
          "const": "SECONDS"
        },
        {
          "const": "MINUTES"
        },
        {
          "const": "HOURS"
        },
        {
          "const": "DAYS"
        }
      ]
    },
    "Duration": {
      "type": "object",
      "properties": {
        "length": {
          "type": "integer"
        },
        "unit": {
          "$ref": "#/$defs/DurationUnit"
        },
        "finite": {
          "type": "boolean",
          "default": true
        },
        "unevaluatedProperties": false
      }
    },
    "LockV1": {
      "type": "object",
      "properties": {
        "path": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Name of the lock"
        },
        "timeout": {
          "type": "integer",
          "description": "TODO"
        },
        "pollTime": {
          "$ref": "#/$defs/Duration",
          "description": "TODO. Default 5 seconds"
        },
        "refreshTime": {
          "$ref": "#/$defs/Duration",
          "description": "TODO. Default 5 seconds"
        }
      },
      "unevaluatedProperties": false
    },
    "AuditV1": {
      "type": "object",
      "properties": {
        "path": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
        },
        "sink": {
          "$ref": "#/$defs/AllSinksV1",
          "description": "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set."
        },
        "maxErrors": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Output domain in output Area (Will be the Database name in Hive or Dataset in BigQuery)"
        },
        "database": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Dataset Name in output Area (Will be the Table name in Hive & BigQuery)"
        },
        "domain": {
          "$ref": "#/$defs/ConvertibleToString"
        },
        "active": {
          "type": "boolean",
          "description": "Output table description"
        },
        "sql": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        }
      },
      "required": [],
      "unevaluatedProperties": false
    },
    "AttributeDescV1": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Column name"
        },
        "comment": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Column description"
        },
        "accessPolicy": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Access policy to apply to this column"
        }
      },
      "required": ["name"],
      "unevaluatedProperties": false
    },
    "DomainV1": {
      "type": "object",
      "description": "A schema in JDBC database or a folder in HDFS or a dataset in BigQuery.",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Domain name. Make sure you use a name that may be used as a folder name on the target storage.\n                   - When using HDFS or Cloud Storage,  files once ingested are stored in a sub-directory named after the domain name.\n                   - When used with BigQuery, files are ingested and sorted in tables under a dataset named after the domain name."
        },
        "metadata": {
          "$ref": "#/$defs/MetadataV1"
        },
        "tables": {
          "type": "array",
          "description": "List of schemas for each dataset in this domain.\nA domain usually contains multiple schemas. Each schema defining how the contents of the input file should be parsed.\nSee Schema for more details.",
          "items": {
            "$ref": "#/$defs/TableV1"
          }
        },
        "comment": {
          "description": "Domain Description (free text)",
          "$ref": "#/$defs/ConvertibleToString"
        },
        "tags": {
          "description": "Set of string to attach to this domain",
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          }
        },
        "rename": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "If present, the attribute is renamed with this name"
        },
        "database": {
          "description": "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set.",
          "$ref": "#/$defs/ConvertibleToString"
        }
      },
      "unevaluatedProperties": false
    },
    "AutoJobDescV1": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Optional name. If not specified, the name of the file without the extension is used."
        },
        "tasks": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/AutoTaskDescV1",
            "description": "List of transform tasks to execute"
          }
        },
        "comment": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Optional description."
        },
        "default": {
          "$ref": "#/$defs/AutoTaskDescV1",
          "description": "Default task properties to apply to all tasks defined in tasks section and in included files"
        }
      },
      "unevaluatedProperties": false
    },
    "JDBCTableV1": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Table name. Set to '*' to extract all tables. Scope: Schema and Data extraction."
        },
        "columns": {
          "description": "List of columns to extract. All columns by default.",
          "type": "array",
          "minItems": 1,
          "items": {
            "oneOf": [
              {
                "$ref": "#/$defs/ConvertibleToString",
                "description": "Column name to extract. Scope: Schema and Data extraction."
              },
              {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/$defs/ConvertibleToString",
                    "description": "Column name to extract. Scope: Schema and Data extraction."
                  },
                  "rename": {
                    "$ref": "#/$defs/ConvertibleToString",
                    "description": "Rename database column name. Scope: Schema and Data extraction."
                  }
                },
                "required": [
                  "name"
                ],
                "unevaluatedProperties": false
              }
            ]
          }
        },
        "partitionColumn": {
          "$ref": "#/$defs/ConvertibleToString"
        },
        "numPartitions": {
          "type": "integer"
        },
        "connectionOptions": {
          "$ref": "#/$defs/MapString"
        },
        "fetchSize": {
          "type": "integer"
        },
        "fullExport": {
          "type": "boolean"
        }
      },
      "unevaluatedProperties": false
    },
    "OutputV1": {
      "type": "object",
      "properties": {
        "encoding": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Specifies encoding (charset) of saved CSV files."
        },
        "withHeader": {
          "type": "boolean",
          "description": "If true, writes the names of columns as the first line."
        },
        "separator": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Character used as a separator for each field and value. TODO: check if we are expecting character."
        },
        "quote": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Character used for escaping quoted values where the separator can be part of the value. TODO: check if we are expecting character."
        },
        "escape": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Character used for escaping quotes inside an already quoted value. TODO: check if we are expecting character."
        },
        "nullValue": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "String representation of a null value."
        },
        "datePattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Java date pattern to apply on date object. Have a look at https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html"
        },
        "timestampPattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Java timestamp pattern to apply on timestamp object. Have a look at https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html"
        }
      },
      "unevaluatedProperties": false
    },
    "JDBCSchemaBase": {
      "type": "object",
      "properties": {
        "catalog": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Optional catalog name in the source database. Scope: Schema and Data extraction."
        },
        "schema": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Database schema where source tables are located. For mysql use this instead of catalog. Scope: Schema and Data extraction."
        },
        "tableRemarks": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Query template used to retrieve table remark. Available variables: catalog, schema, table. Scope: Schema extraction."
        },
        "columnRemarks": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Query template used to retrieve all columns' remark of a table. Available variables: catalog, schema, table. Scope: Schema extraction."
        },
        "tableTypes": {
          "description": "One or many of the predefined table types. Scope: Schema and Data extraction.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/TableTypeV1"
          }
        },
        "template": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Template used during schema extraction in order to generate load files (domain and tables). Scope: Schema extraction."
        },
        "pattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Pattern template used to define load tables' file pattern. Available variables: catalog, schema, table. Scope: Schema extraction."
        },
        "numericTrim": {
          "$ref": "#/$defs/TrimV1",
          "description": "Trim strategies applied to numeric fields set on load table's definition. Scope: Schema extraction."
        },
        "partitionColumn": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Column to use in order to parallelize data extraction. Scope: Data extraction."
        },
        "numPartitions": {
          "type": "integer",
          "description": "Number of data partitions to create. Scope: Data extraction."
        },
        "connectionOptions": {
          "$ref": "#/$defs/MapString",
          "description": "Options to set on data connection. Scope: Data extraction."
        },
        "fetchSize": {
          "type": "integer",
          "description": "Number of rows to be fetched from the database when additional rows are needed. By default, most JDBC drivers use a fetch size of 10, so if you are reading 1000 objects, increasing the fetch size to 256 can significantly reduce the time required to fetch the query's results. The optimal fetch size is not always obvious. Scope: Data extraction."
        },
        "stringPartitionFunc": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "SQL template used on partition column's of type String. Some implementations are already defined, see ai.starlake.extract.JdbcDbUtils.getStringPartitionFunc. Mandatory variables: col, nb_partitions. Scope: Data extraction."
        },
        "fullExport": {
          "type": "boolean",
          "description": "Define if we should fetch the entire table's or not. If not, maximum value of partitionColumn seen during last extraction is used in order to fetch incremental data. Scope: Data extraction."
        },
        "sanitizeName": {
          "type": "boolean",
          "description": "Sanitize domain's name by keeping alpha numeric characters only. Scope: Schema and Data extraction."
        }
      }
    },
    "DefaultJDBCSchemaV1": {
      "$ref": "#/$defs/JDBCSchemaBase",
      "unevaluatedProperties": false
    },
    "JDBCSchemaV1": {
      "type": "object",
      "allOf": [
        {
          "$ref": "#/$defs/JDBCSchemaBase"
        },
        {
          "properties": {
            "tables": {
              "type": "array",
              "description": "List of tables to extract. Scope: Schema and Data extraction.",
              "items": {
                "$ref": "#/$defs/JDBCTableV1"
              }
            },
            "exclude": {
              "type": "array",
              "description": "List of tables to exclude. Applied on tables list. Scope: Schema and Data extraction.",
              "items": {
                "$ref": "#/$defs/ConvertibleToString"
              }
            },
            "filter": {
              "$ref": "#/$defs/ConvertibleToString",
              "description": "Filter applied along data extraction. Scope: Data extraction"
            }
          }
        }
      ],
      "unevaluatedProperties": false
    },
    "JDBCSchemasV1": {
      "type": "object",
      "properties": {
        "jdbcSchemas": {
          "description": "Describe what to fetch from data connection. Scope: Schema and Data extraction.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/JDBCSchemaV1"
          }
        },
        "connectionRef": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Connection used to retrieve at least data from it. If not defined, fallback to application settings. Expected connection name as defined in the connections section of the application.conf file. Scope: Schema and data extraction."
        },
        "auditConnectionRef": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Connection used to read/store audit from it. If not defined, fallbacks to connectionRef. Expected connection name as defined in the connections section of the application.conf file. Scope: Data extraction."
        },
        "output": {
          "$ref": "#/$defs/OutputV1",
          "description": "Override the output format of data extraction. Scope: Data extraction."
        },
        "default": {
          "$ref": "#/$defs/JDBCSchemaV1",
          "description": "Configuration merged into each jdbcSchemas. Scope: Schema and Data extraction."
        }
      },
      "unevaluatedProperties": false
    },
    "InputRefV1": {
      "description": "Input for ref object",
      "type": "object",
      "properties": {
        "database": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Database pattern to match, none if any database"
        },
        "domain": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Domain pattern to match, none if any domain match"
        },
        "table": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Table pattern to match"
        }
      },
      "required": ["table"],
      "unevaluatedProperties": false
    },
    "OutputRefV1": {
      "description": "Output for ref object",
      "type": "object",
      "properties": {
        "database": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": ""
        },
        "domain": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": ""
        },
        "table": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": ""
        }
      },
      "required": ["table", "domain", "database"],
      "unevaluatedProperties": false
    },
    "RefV1": {
      "description": "Describe how to resolve a reference in a transform task",
      "type": "object",
      "properties": {
        "input": {
          "$ref": "#/$defs/InputRefV1",
          "description": "The input table to resolve"
        },
        "output": {
          "$ref": "#/$defs/OutputRefV1",
          "description": "The output table resolved with the domain and database"
        }
      },
      "required": ["input", "output"],
      "unevaluatedProperties": false
    },
    "KafkaTopicConfigV1": {
      "properties": {
        "topicName": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "maxRead": {
          "type": "integer",
          "description": "TODO"
        },
        "fields": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ConvertibleToString"
          },
          "description": "TODO"
        },
        "partitions": {
          "type": "integer",
          "description": "TODO"
        },
        "replicationFactor": {
          "type": "integer",
          "description": "TODO"
        },
        "createOptions": {
          "$ref": "#/$defs/MapString",
          "description": "TODO"
        },
        "accessOptions": {
          "$ref": "#/$defs/MapString",
          "description": "TODO"
        },
        "headers": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MapString"
          },
          "description": "TODO"
        }
      },
      "unevaluatedProperties": false
    },
    "KafkaConfigV1": {
      "type": "object",
      "properties": {
        "serverOptions": {
          "$ref": "#/$defs/MapString",
          "description": "TODO"
        },
        "topics": {
          "type": "object",
          "description": "Map of topic configs",
          "additionalProperties": {
            "$ref": "#/$defs/KafkaTopicConfigV1"
          }
        },
        "cometOffsetsMode": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "customDeserializers": {
          "$ref": "#/$defs/MapString",
          "description": "TODO"
        }
      },
      "unevaluatedProperties": false
    },
    "DagRefV1": {
      "type": "object",
      "properties": {
        "load": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "transform": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        }
      },
      "unevaluatedProperties": false
    },
    "HttpV1": {
      "type": "object",
      "properties": {
        "interface": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "port": {
          "type": "integer",
          "description": "TODO"
        }
      },
      "unevaluatedProperties": false
    },
    "AppConfigV1": {
      "type": "object",
      "properties": {
        "env": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default environment to use. May be also set using the SL_ENV environment variable"
        },
        "datasets": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "When using filesystem storage, default path to store the datasets"
        },
        "dags": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "DAG generation config folder. metadata/dags by default"
        },
        "metadata": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "default metadata folder name. May be also set using the SL_METADATA environment variable"
        },
        "metrics": {
          "$ref": "#/$defs/MetricsV1"
        },
        "validateOnLoad": {
          "type": "boolean",
          "description": "Validate the YAML file when loading it. If set to true fails on any error"
        },
        "audit": {
          "$ref": "#/$defs/AuditV1"
        },
        "archive": {
          "type": "boolean",
          "description": "Should ingested files be archived after ingestion ?"
        },
        "sinkReplayToFile": {
          "type": "boolean",
          "description": "Should invalid records be stored in a replay file ?"
        },
        "lock": {
          "$ref": "#/$defs/LockV1"
        },
        "defaultWriteFormat": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default write format in Spark. parquet is the default"
        },
        "defaultRejectedWriteFormat": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default write format in Spark for rejected records. parquet is the default"
        },
        "defaultAuditWriteFormat": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default write format in Spark for audit records. parquet is the default"
        },
        "csvOutput": {
          "type": "boolean",
          "description": "output files in CSV format ? Default is false"
        },
        "csvOutputExt": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "CSV file extension when csvOutput is true. Default is .csv"
        },
        "privacyOnly": {
          "type": "boolean",
          "description": "Only generate privacy tasks. Reserved for internal use"
        },
        "emptyIsNull": {
          "type": "boolean",
          "description": "Should empty strings be considered as null values ?"
        },
        "loader": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default loader to use when none is specified in the schema. Valid values are 'spark' or 'native'. Default is 'spark'"
        },
        "rowValidatorClass": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": ""
        },
        "treeValidatorClass": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": ""
        },
        "loadStrategyClass": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "In what order should the files for a same table be loaded ? By time (default) or by or name ?\n",
          "enum": [
            "ai.starlake.job.load.IngestionNameStrategy",
            "ai.starlake.job.load.IngestionTimeStrategy"
          ]
        },
        "hive": {
          "type": "boolean",
          "description": "Should we create the table in Hive ? (useful for Spark / Databricks) "
        },
        "grouped": {
          "type": "boolean",
          "description": "Should we load of the files to be stored in the same table in a single task or one by one ?"
        },
        "groupedMax": {
          "type": "integer",
          "description": "Maximum number of files to be stored in the same table in a single task"
        },
        "scd2StartTimestamp": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "scd2EndTimestamp": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "area": {
          "$ref": "#/$defs/AreaV1",
          "description": "pending, accepted ... areas configuration"
        },
        "hadoop": {
          "$ref": "#/$defs/MapString",
          "description": "Hadoop configuration if applicable"
        },
        "connections": {
          "$ref": "#/$defs/MapConnectionV1",
          "description": "Connections configurations"
        },
        "jdbcEngines": {
          "$ref": "#/$defs/MapJdbcEngineV1",
          "description": "JDBC engine configurations"
        },
        "privacy": {
          "$ref": "#/$defs/PrivacyV1",
          "description": "Privacy algorithms"
        },
        "root": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Root folder for the application. May be also set using the SL_ROOT environment variable"
        },
        "internal": {
          "$ref": "#/$defs/InternalV1",
          "description": "Internal configuration"
        },
        "accessPolicies": {
          "$ref": "#/$defs/AccessPoliciesV1",
          "description": "Access policies configuration"
        },
        "sparkScheduling": {
          "$ref": "#/$defs/SparkSchedulingV1",
          "description": "Spark Job scheduling configuration"
        },
        "udfs": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Coma separated list of UDF to register in Spark jobs. May be also set using the SL_UDFS environment variable"
        },
        "expectations": {
          "$ref": "#/$defs/ExpectationsConfigV1",
          "description": "Expectations configuration"
        },
        "sqlParameterPattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Pattern to use to replace parameters in SQL queries in addition to the jinja syntax {{param}}. Default is ${param}"
        },
        "rejectAllOnError": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Should we reject all records when an error occurs ? Default is false"
        },
        "rejectMaxRecords": {
          "type": "integer",
          "description": "Maximum number of records to reject when an error occurs. Default is 100"
        },
        "maxParCopy": {
          "type": "integer",
          "description": ""
        },
        "kafka": {
          "$ref": "#/$defs/KafkaConfigV1",
          "description": "TODO"
        },
        "dsvOptions": {
          "$ref": "#/$defs/MapString",
          "description": "DSV ingestion extra options"
        },
        "rootServe": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "forceViewPattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "forceDomainPattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "forceTablePattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "forceJobPattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "forceTaskPattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "useLocalFileSystem": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "sessionDurationServe": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "database": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default target database (projectId in GCP). May be also set using the SL_DATABASE environment variable"
        },
        "tenant": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "reserved"
        },
        "connectionRef": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "Default connection to use when loading / transforming data"
        },
        "schedulePresets": {
          "$ref": "#/$defs/MapString",
          "description": "Default connection to use when loading / transforming data"
        },
        "maxParTask": {
          "type": "integer",
          "description": "How many job to run simultaneously in dev mode (experimental)"
        },
        "refs": {
          "type": "array",
          "description": "TODO",
          "items": {
            "$ref": "#/$defs/RefV1"
          }
        },
        "dagRef": {
          "$ref": "#/$defs/DagRefV1",
          "description": "Default connection to use when loading / transforming data"
        },
        "forceHalt": {
          "type": "boolean",
          "description": "Force application to stop even when there is some pending thread."
        },
        "jobIdEnvName": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "archiveTablePattern": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "archiveTable": {
          "type": "boolean",
          "description": "TODO"
        },
        "version": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "autoExportSchema": {
          "type": "boolean",
          "description": "TODO"
        },
        "longJobTimeoutMs": {
          "type": "integer",
          "description": "TODO"
        },
        "shortJobTimeoutMs": {
          "type": "integer",
          "description": "TODO"
        },
        "createSchemaIfNotExists": {
          "type": "boolean",
          "description": "TODO"
        },
        "http": {
          "$ref": "#/$defs/HttpV1",
          "description": "TODO"
        },
        "timezone": {
          "$ref": "#/$defs/ConvertibleToString",
          "description": "TODO"
        },
        "spark": {
          "type": "object",
          "description": "Map of string",
          "additionalProperties": true
        },
        "extra": {
          "type": "object",
          "description": "Map of string",
          "additionalProperties": true
        }
      },
      "unevaluatedProperties": false
    },
    "StarlakeV1": {
      "type": "object",
      "properties": {
        "types": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TypeV1"
          }
        },
        "dag": {
          "$ref": "#/$defs/DagGenerationConfigV1"
        },
        "extract": {
          "$ref": "#/$defs/JDBCSchemasV1"
        },
        "load": {
          "$ref": "#/$defs/DomainV1"
        },
        "transform": {
          "$ref": "#/$defs/AutoJobDescV1"
        },
        "task": {
          "$ref": "#/$defs/AutoTaskDescV1"
        },
        "env": {
          "$ref": "#/$defs/MapString"
        },
        "table": {
          "$ref": "#/$defs/TableV1"
        },
        "tables": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TableV1"
          }
        },
        "external": {
          "$ref": "#/$defs/ExternalSourceV1"
        },
        "refs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/RefV1"
          }
        },
        "application": {
          "$ref": "#/$defs/AppConfigV1"
        }
      },
      "oneOf": [
        {
          "required": [
            "extract"
          ]
        },
        {
          "required": [
            "load"
          ]
        },
        {
          "required": [
            "transform"
          ]
        },
        {
          "required": [
            "env"
          ]
        },
        {
          "required": [
            "types"
          ]
        },
        {
          "required": [
            "tables"
          ]
        },
        {
          "required": [
            "table"
          ]
        },
        {
          "required": [
            "task"
          ]
        },
        {
          "required": [
            "external"
          ]
        },
        {
          "required": [
            "application"
          ]
        },
        {
          "required": [
            "refs"
          ]
        },
        {
          "required": [
            "dag"
          ]
        }
      ]
    }
  }
}
